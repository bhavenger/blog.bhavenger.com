+++
date = "2016-07-20T22:19:01+03:00"
description = ""
draft = true
tags = ["vault", "hashicorp", "security"]
title = "vault101"
topics = []

+++

# Vault 101 - или как решить множество проблем хранения секретов
## Disclaimer
Как и вы, я устал от многочисленных переводов зарубежных статей, которые, в свою очередь, часто являются пересказом официальной документации. Поэтому в этой статье вы не найдете пересказа документации. Я лишь хочу поделиться собственным production-опытом использования. Если вам захочется подробнее понять, как работает Vault - добро пожаловать в качественную документацию на английском языке.

## Обозначения
Ключ, он же токен - комбинация символов, однозначно идентифицирующая пользователя и разрешенный для него набор операций.  

## Какие проблемы решаем?
Безопасность вообще и управление секретами в частности - это сложно.  
Если у вас используется система управления конфигурациями(Puppet, Chef, Ansible, Salt, whatever) - то при первом приближении к проблеме можно, например, хранить все секреты рядом с кодом вашей CM-системы. Выглядит разумно, не нужно совершать никаких дополнительных действий, где-то получать секреты, всё рядом - всё удобно. Проблемы начинаются, когда доступ к вашему репозиторию получают другие люди. Ваш репозиторий становится единой точкой хранения всех секретов, к которым вы имеет доступ. Это очень небезопасно и очень неудобно.  Например после увольнения одного человека из тех, кто имел доступ к этому репозиторию вы вынуждены поменять ВСЕ секреты, которым там были представлены. Также каждое появление этого репозитория где-то в инфраструктуре добавляет вам точек отказа - будь-то Jenkins, разные chef\puppet-сервера для разных окружений  или просто необходимость запускать по крону с одного сервера маленький скриптик, которых хранится в этом репозитории - вы получаете риски в обмен на ‘удобство’ и возможность не думать про безопасность.
Ок, что делать? Опытные пользователи систем управления конфигурациями скажут - это уже решили в моей $scm-name. Ansible vault, Puppet gpg-hiera, Chef encrypted data bags и так далее. Всё бы хорошо, но есть проблемы(куда без них) - ключ для расшифровки этих хранилищ всё еще доступен на большом количестве серверов. Вы по-прежнему не знаете, кто получал доступ к секретам и не знаете к каким именно секретам был доступ.
Ок, что же все-таки делать? Как можно было догадаться из названия статьи - использовать Hashicorp Vault!
## Основные фичи Vault
- Все данные хранятся в зашифрованном контейнере. Получение самого контейнера не раскрывает данные.
- Гибкие политики доступа. Вы можете создать столько токенов для доступа и управления секретами, сколько вам нужно. И дать им именно те разрешения, которые необходимы и достаточны для выполнения работ, но не более того.
- Возможность аудирования доступа к секретам. Каждый запрос к Vault может и должен быть записан в лог для последующего аудита.
- Различные бекенды для хранения секретов. Можно просто хранить секреты, а можно генерировать их автоматически. Поддерживается автоматическая генерация секретов для нескольких популярных баз данных(postgresql, mysql, mssql, cassandra), для rabbitmq, ssh и для aws.
- Поддержка шифрования-дешифрования данных без их сохранения. Это может быть удобно для передачи данных в зашифрованном виде по незащищенным каналам связи.
- Поддержка полного жизненного цикла секрета - создание/отзыв/ завершение срока хранения/продление.
- Уберфича, значимость которой сложно переоценить - это возможность создания собственного CA(Certificate Authority) для управления самоподписанными сертификатами внутри своей инфраструктуры.
- Наличие готовых модулей и плагинов для всех популярных систем управления конфигурацией.  
## Начало работы
Итак, после установки и запуска Vault(более подробно - в официальной документации и в https://www.amon.cx/blog/managing-all-secrets-with-vault/) в HA-режиме(я использую Consul для этого) возникают вопросы:
- Сколько ключей вам будет нужно для того, чтобы распечатать хранилище(Распечатывание - это исключительно ручной процесс, во время которого зашифрованный контейнер с секретами помещается в память и восстанавливается мастер-ключ для расшифровки. Более подробно - [тут](https://www.vaultproject.io/docs/concepts/seal.html). Каждый решает этот вопрос по-своему. Дать возможность распечатать хранилище одному человеку - большой риск, потому-что при компрометации этого ключа\ключей злоумышленники получат доступ к хранилищу(но пока не к секретам). Надо понимать, что если вы не сможете набрать необходимый минимум ключей для распечатывания хранилища - доступ к данным будет утерян. Для себя я решил, что достаточно 4 владельцев ключей и 2 ключей для расшифровки.
- Сколько root-токенов будет в вашей системе. Эти токены должны использоваться только для управления политиками, ролями, настройками системы и выдачи токенов для сервисов. Надо понимать, что чем меньше root-ключей в системе - тем меньше вероятности компрометации одного из ключей. Но чем меньше таких ключей в системе - тем больше всё завязывается на определенных людей, которые болеют, ходят в отпуск, в общем - бывают недоступны. Для себя я решил, что достаточно 4 владельцев root-ключей, это те же люди, что обладают ключами для распечатки хранилища.
- Как вы будете хранить секреты и как вы будете управлять доступами к ним? Можно разделять по окружениям или сервисам. Или любым другим удобным вам способом. Для себя я выбрал следующую схему - /secret/$service_name/$env. Для каждого $service_name есть владелец, обладающий полным доступом для /secret/$service_name/* и умеющий создавать ключи в рамках своих доступов(например read-only для автоматизированных запросов). И есть /secret/infra/* где обслуживаются обще-инфраструктурные ключи(например api-token для jenkins или реквизиты для доступа к пакетному репозиторию). Для себя я решил, что владельцы секретов общей инфраструктуры - это обладатели рутовых ключей.
- Какой структуры секретов вы будете придерживаться?
```
{secret: {infra: {dns: {dns_key_secret: {value: $dns_key_secret }}}}}
```
или, например
```
{secret: {infra: {dns: {dns_key_secret: $dns_key_secret }}}}
```
Нужно решить этот вопрос до того, как ваш список секретов начнет быстро расти и вы начнете прикручивать различные средства автоматизации.
  
Ок, вы ответили на эти вопросы, засетапили себе сервис и начали его использовать, что дальше? А дальше просто эксплуатация и счастливая безопасная жизнь :)
## Неочевидные и/или полезные вещи
Для того, чтобы созданный вами НЕ-root токен мог создавать новые токены он должен иметь политику
```
path "auth/token/create" {
  policy = "write"
}
```
НЕ-root токен может создавать токен только с теми политиками, которыми он обладает. Это означает, что вам недостаточно выдать вашему токену политику $service_name-prod-root,
```
path "secret/$service_name/prod/*" {  
  policy = "write"  
}
```
которая обладает полным доступом к secret/$service_name/prod/*, но также нужно озаботиться, например, политикой $service_name-prod-read
```
path "secret/$service_name/prod/*" {  
  policy = "read"  
}
```
и тогда вы сможете создавать токены для read-only доступа с помощью команды
```
vault token-create -policy=$service_name-prod-read  
```  
  
Чтобы не вводить свой рабочий токен постоянно, его можно положить в $HOME/.vault-token или в переменную окружения VAULT_TOKEN.  
  
Если токен был родительским для других токенов - то по умолчанию при отзыве этого токена все токены и секреты, созданные отзываемым токеном, отзываются рекурсивно. Этого можно избежать,  указав флаг -mode. Более подробно
```
vault token-revoke -h
```
  
ВАЖНО. Не существует простого способа узнать, какие ключи существуют в системе. Если вы создали токен и забыли о нём, не записав никакой информации - то вам придется дожидаться, пока у него закончится срок жизни. Root-токены не имеют срока жизни, поэтому будут висеть в вашей системе бесконечно.  
  
Для избавления от этой ситуации во время создания нового токена в целях тестирования и проверки вы можете указать прекрасный флаг *-ttl="1h"*, который устанавливает время жизни. Это позволит спокойно работать, не боясь бесконтрольно увеличить количество токенов.  
  
Каждый токен имеет параметр --accessor, зная который можно взаимодействовать с токеном, не зная его самого(например отзывать, обновлять, добавлять политики), например

```
vault token-revoke --accessor b30ee2a3-ea4b-9da0-3e5c-4189d375cad9
```
Хорошей практикой является записывание этих ключей для последующей работы с ними. Это позволяет проводить быстрый аудит активных доступов в системе.  
  
Если вы будете использовать consul-template для автоматической перегенерации конфигов при изменении секретов - имейте в виду(и этого вы не найдете в документации), что consul-template опрашивает изменение секрета в двух случаях:  
- Старт или рестарт самого consul-template.  
- Каждые (ttl секрета/2) секунд после старта consul-template.  




