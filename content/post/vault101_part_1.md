+++
date = "2016-07-20T22:19:01+03:00"
description = ""
draft = true
tags = ["vault", "hashicorp", "security"]
title = "vault101"
topics = []

+++

# Vault 101, или как решить множество проблем хранения секретов.
![Vault header](http://pocketstudio.jp.s3.amazonaws.com/log3/wp-content/uploads/2015/07/hahsicorp-vaule-header2-670x262.png)
## Disclaimer
Как и вы, я устал от многочисленных переводов зарубежных статей, которые, в свою очередь, часто являются пересказом официальной документации. Поэтому в первой части я расскажу, зачем это всё, во второй я перескажу официальную документацию самостоятельно ;-P, а в третьей поделюсь своим реальным опытом использования и некоторыми неочевидными при первом приближении подробностями.

## Определения
Токен, он же ключ - комбинация символов, однозначно идентифицирующая клиента и разрешённый для него набор операций.    
Секрет - совокупность данных, необходимая для аутентификации и авторизации клиента на вашем сервисе(например логин и пароль от базы данных). Токен тоже является секретом по своей сути.  
Деплой - процесс доставки и развёртывания кода.  

## Какие проблемы решаем?
Разберём простую ситуацию - у вас есть сервис, состоящий из приложения на динамическом языке и реляционной базы данных. Приложение для своей работы использует данные, находящиеся в базе данных. Давайте посмотрим, какие секреты _скорее всего_ присутствуют в этой простейшей схеме?
1. Логин и пароль от базы данных для приложения(с ограниченным набором разрешённых операций).
2. Логин и пароль от базы данных для осуществления административных действий(создание и удаление баз данных, миграции, изменение конфигурации, whatever).
3. Ключ доступа на сервера для администратора.
4. Ключ доступа на сервер приложения для деплоя новой версии кода.
5. Ключ доступа на приватный репозиторий в GitHub(или любой другой хостинг, включая ваш собственный) для разработчика системы.
6. Ключ доступа на приватный репозиторий для системы деплоя.

Многовато получилось. А ведь это простейшая на первый взгляд схема.  
Что же делать, чтобы минимизировать риски, связанные с этими секретами? И при чём тут Vault? Давайте разбираться.

## Разбираемся.
Посмотрим на наш список секретов. Допустим мы храним ключи доступа администратора только на его ноутбуке в зашифрованном виде. О них можно практически не беспокоиться. Остаются два секрета доступа к базе данных(пользовательский и администраторский), ключ доступа на сервер приложения и ключ доступа к репозиторию для сервиса деплоя.
Всеми этими секретами так или иначе должен обладать сервис деплоя(он доставляет код с конфигом доступа к базе данных на сервер приложения; он накатывает миграции в процессе деплоя; он получает код из приватного репозитория).
Например вы используете Jenkins. Может быть отдать хранение секретов ему? Проблемы начинаются сразу после небольшого изыскания.
Любой, обладающий доступом к Jenkins может использовать ваши секреты в своей задаче - и таким образом получить к ним доступ.   Любой, кто получил доступ к Jenkins на уровне сервера - легко может [вытащить эти данные](http://thiébaud.fr/jenkins_credentials.html).
  
А что если хранить эти секреты в репозитории? Тут есть следующие проблемы:
Репозиторий хранится на сервере приложения и содержит секретов больше, чем необходимо самому приложению для работы.
Репозиторий хранится также и на сервере с Jenkins.
Вы не можете дать доступ к репозиторию без доступа ко всем секретам вашего сервиса.
  
Я настраиваю свои сервера с помощью системы управления конфигурациями. Почему бы не хранить эти секреты там?
Выглядит разумно - единая точка хранения секретов, Jenkins доступа не имеет. На конечных серверах можно раскладывать только тот набор секретов, который необходим и достаточен для работы.
Проблемы начинаются, когда доступ к вашему репозиторию получают другие люди. Ваш репозиторий становится единой точкой хранения всех секретов, к которым вы имеете доступ. Это очень небезопасно и очень неудобно. Например, после увольнения одного человека из тех, кто имел доступ к этому репозиторию, вы вынуждены поменять ВСЕ секреты, которым там были представлены. Также каждое появление этого репозитория где-либо в инфраструктуре добавляет вам точек отказа. Будь то Jenkins, разные chef\puppet-сервера для разных окружений или просто необходимость запускать по крону с одного сервера маленький скриптик, который хранится в этом репозитории - вы получаете риски в обмен на 'удобство' и возможность не думать про безопасность.
Опытные пользователи систем управления конфигурациями скажут: "Это уже решили в моей $scm-name. Ansible vault, Puppet gpg-hiera, Chef encrypted data bags и так далее". Всё бы хорошо, но есть проблемы (куда без них): ключ для расшифровки этих хранилищ всё ещё доступен на большом количестве серверов. Вы по-прежнему не знаете, кто получал доступ к секретам, и не знаете, к каким именно секретам был доступ. Ок, что же всё-таки делать? Как можно было догадаться из названия статьи - использовать Hashicorp Vault!  

## Что это за Vault такой?
[Vault](https://www.vaultproject.io) - это хранилище секретов. Секреты хранятся в простом key-value виде. Доступ к хранилищу осуществляется исключительно через REST-API.
Основные фичи Vault:
- Все данные хранятся в зашифрованном контейнере. Получение самого контейнера не раскрывает данные.
- Гибкие политики доступа. Вы можете создать столько токенов для доступа и управления секретами, сколько вам нужно. И дать им именно те разрешения, которые необходимы и достаточны для выполнения работ, но не более того.
- Возможность аудирования доступа к секретам. Каждый запрос к Vault может и должен быть записан в лог для последующего аудита.
- Поддерживается автоматическая генерация секретов для нескольких популярных баз данных (postgresql, mysql, mssql, cassandra), для rabbitmq, ssh и для aws.
- Поддержка шифрования-дешифрования данных без их сохранения. Это может быть удобно для передачи данных в зашифрованном виде по незащищённым каналам связи.
- Поддержка полного жизненного цикла секрета: создание/отзыв/завершение срока хранения/продление.
- Уберфича, значимость которой сложно переоценить, это возможность создания собственного CA (Certificate Authority) для управления самоподписанными сертификатами внутри своей инфраструктуры.
- Наличие готовых модулей и плагинов для всех популярных систем управления конфигурацией.  

## Пересказ официальной документации
Нет. Давайте вместе поднимать культуру статей. Getting started можно пройти вот [тут](https://www.vaultproject.io/intro/getting-started/install.html). А [тут](https://www.vaultproject.io/#/demo/0) есть интерактивная обучалка. А [вот](https://www.amon.cx/blog/managing-all-secrets-with-vault/) ещё прекрасная статья.

## Начало работы
Итак, после установки и запуска Vault в HA-режиме (я использую Consul для этого) возникают вопросы:  
  
* Сколько ключей вам будет нужно для того, чтобы распечатать хранилище? (Распечатывание - это исключительно ручной процесс, во время которого зашифрованный контейнер с секретами помещается в память и восстанавливается мастер-ключ для расшифровки. Более подробно - [тут](https://www.vaultproject.io/docs/concepts/seal.html)). Каждый решает этот вопрос по-своему. Дать возможность распечатать хранилище одному человеку - большой риск, потому что при компрометации этого ключа или ключей злоумышленники получат доступ к хранилищу (но пока не к секретам). Надо понимать, что если вы не сможете набрать необходимый минимум ключей для распечатывания хранилища - доступ к данным будет утерян. Для себя я решил, что достаточно 4 владельцев ключей и 2 ключей для расшифровки.
* Сколько root токенов будет в вашей системе? Эти токены должны использоваться только для управления политиками, ролями, настройками системы и выдачи токенов для сервисов. Чем меньше root ключей в системе, тем меньше вероятности компрометации одного из ключей. Но чем меньше таких ключей в системе, тем больше всё завязывается на определённых людей, которые болеют, ходят в отпуск, в общем - бывают недоступны. Для себя я решил, что достаточно 4 владельцев root ключей, это те же люди, что обладают ключами для распечатки хранилища. Понятно, что если вы один или вас двое - то выбирать не приходится.
* Как вы будете хранить секреты и как вы будете управлять доступами к ним? Можно разделять любым удобным вам способом. Главное - чтобы этот способ был един для всей системы. Для себя я выбрал следующую схему - /secret/$service_name/$env. Для каждого $service_name есть владелец, обладающий полным доступом для /secret/$service_name/* и умеющий создавать ключи в рамках своих доступов (например, read-only для автоматизированных запросов). И есть /secret/infra/*, где обслуживаются обще-инфраструктурные ключи (например, api-token для jenkins или реквизиты для доступа к пакетному репозиторию). Для себя я решил, что владельцы секретов общей инфраструктуры - это обладатели рутовых ключей.  
* Какой структуры секретов вы будете придерживаться?  
```
{secret: {infra: {dns: {dns_key_secret: {value: $dns_key_secret }}}}}
```
или, например
```
{secret: {infra: {dns: {dns_key_secret: $dns_key_secret }}}}
```
Нужно решить этот вопрос до того, как ваш список секретов начнёт быстро расти и вы начнёте прикручивать различные средства автоматизации.  
* Как вы будете вести учёт ключей и, быть может, мониторить срок их жизни?
Если не вести учёт - то будет очень сложно проводить аудит системы. А если вы согласились с настройками vault по умолчанию, то максимальный срок жизни НЕ root токена равен 30 дням. Это означает, что вам нужно как-то за этим следить, может быть настроить мониторинг. Завести процессы замены этих токенов, может быть где-то что-то автоматизировать. Для себя я решил, что мы ведем список ключей(не самих ключей, а ключей, с помощью которых можно узнать что-то о самом ключе, который они представляют. Более подробно - [тут](https://www.hashicorp.com/blog/vault-0.6.html#token-accessors) и ниже) в репозитории и мониторим ключи из этого списка.
  
## Работа  

Допустим мы ответили на некоторые вопросы, но что-то нам ещё не понятно. Давайте вернёмся к нашему примеру с приложением и базой данных и попробуем разобраться вместе.
Для простоты решим, что вы работаете один и попробуем начать работать с одним из ключей - например с ключом для доступа приложения к базе данных.
Итак, первым делом нам нужно положить наш ключ в хранилище. Согласно рекомендациям нам для начала требуется создать отдельный токен, который должен уметь следующее:
* записывать и изменять секреты
* читать секреты
* уметь создавать другие токены 

Всё это управляется с помощью политик. Они описываются в формате [JSON](http://www.json.org/json-ru.html) или [HCL](https://github.com/hashicorp/hcl) и записываются в Vault с помощью запроса к API или через cli. Например, так:
```vault policy-write $policy_name $policy_file.hcl``` 
Для того, чтобы созданный вами НЕ root токен мог создавать новые токены, он должен иметь политику
```
path "auth/token/create" {
  policy = "write"
}
```
НЕ root токен может создавать токен только с теми политиками, которыми он обладает. Это означает, что вам недостаточно выдать вашему токену политику $service_name-prod-root,
```
path "secret/$service_name/prod/*" {  
  policy = "write"  
}
```
которая обладает полным доступом к secret/$service_name/prod/*, но также нужно озаботиться, например, политикой $service_name-prod-read,
```
path "secret/$service_name/prod/*" {  
  policy = "read"  
}
```
и тогда вы сможете создавать токены для read-only доступа с помощью команды
```vault token-create -policy=$service_name-prod-read```  
Важное уточнение: политики применяются по степени детализации. Это означает, что если вы сделаете root политику вида
```
path "secret/service_name/prod/*" {  
  policy = "write"  
}
```
и захотите дать доступ на чтение политике $service_name-prod-database-read
```
path "secret/service_name/prod/database/*" {  
  policy = "read"  
}
```
то вам нужно будет назначить токену, управляющему этим сервисом обе этих политики. После того, как вы это сделаете - вы не сможете писать в secret/$service_name/prod/database/*. Чтобы этого не случилось - вам придется уравновесить каждую детализированную политику на чтение, например видоизменить политику $service_name-prod-root так
```
path "secret/service_name/prod/*" {  
  policy = "write"  
}

path "secret/service_name/prod/database/*" {  
  policy = "write"  
}
```
Ок, разобрались и создали все необходимые политики. Пора создавать токены и работать с секретами.
Из под root ключа создаём ключ для работы с нашим сервисом service_name.
```
$ vault token-create -policy=service_name-prod-root -policy=service_name-prod-read
Key             Value
---             -----
token           82c5fb97-da1b-1d2c-cfd5-23fa1dca7c85
token_accessor  dd256e17-b9d9-172d-981b-a70422e12cb8
token_duration  2592000
token_renewable true
token_policies  [default, service_name-prod-root, service_name-prod-read ]
```
Разберём формат:
```
token - это тот самый ключ доступа к Vault.
token_accessor - это это ключ, по которому можно производить действия с ключом, не имея самого ключа. Разрешены следующие действия - посмотреть на метаданные токена, отозвать токен.
token_duration - время жизни токена в секундах.
token_renewable - если true - то время жизни токена может быть обновлено, но не более чем на срок от времени создания до параметра max-lease-ttl, который по умолчанию также 30d. Это означает, что если вы создали токен со сроком жизни в 30 дней и максимальный срок жизни тоже 30 дней - то обновить вы его не сможете.
token_policies - это политики, которые назначены токену. Список политик изменить невозможно, возможно только отозвать токен и пересоздать заново.
```
Записываем token_accessor куда-нибудь - далее мы будем использовать его для проведения аудита и мониторинга истечения срока жизни токена.
Авторизуемся под новым токеном:
```
$ vault auth 82c5fb97-da1b-1d2c-cfd5-23fa1dca7c85
```
Записываем наш секрет:
```
$ vault write secret/service_name/prod/database base=appname login=appname password=difficult_password
```
Генерируем токен для чтения:
```
$ vault token-create -policy=service_name-prod-read
Key             Value
---             -----
token           cb347ae0-9eb4-85d1-c556-df43e82be4b0
token_accessor  c8996492-17e3-16a7-2af1-d58598ae10d8
token_duration  2592000
token_renewable true
token_policies  [default, service_name-prod-read ]
```
Опять записываем token_accessor для последующего аудита и мониторинга.
Проверим, что есть доступ на чтение:
```
$ vault auth 82c5fb97-da1b-1d2c-cfd5-23fa1dca7c85
$ vault read secret/service_name/prod/database
Key             Value
lease_duration  2592000
base            appname
login           appname
password        difficult_password
```
Всё работает, мы готовы использовать наш токен в системах автоматизации.





## Неочевидности(переписать)
Если токен был родительским для других токенов, то по умолчанию при отзыве этого токена все токены и секреты, созданные отзываемым токеном, отзываются рекурсивно. Этого можно избежать,  указав флаг -mode. Более подробно
```vault token-revoke -h```
  
ВАЖНО. Не существует простого способа узнать, какие ключи существуют в системе. Если вы создали токен и забыли о нём, не записав никакой информации, то вам придется дожидаться, пока у него закончится срок жизни. Root-токены не имеют срока жизни, поэтому будут висеть в вашей системе бесконечно.  
  
Чтобы избавиться от этой ситуации, во время создания нового токена в целях тестирования и проверки вы можете указать прекрасный флаг -ttl="1h", который устанавливает время жизни. Это позволит спокойно работать и не бояться бесконтрольно увеличить количество токенов.
  
Каждый токен имеет параметр --accessor, зная который можно взаимодействовать с токеном, не зная его самого (например, отзывать, обновлять, добавлять политики), например

```vault token-revoke --accessor b30ee2a3-ea4b-9da0-3e5c-4189d375cad9```
Хорошей практикой является записывание этих ключей для последующей работы с ними. Это позволяет проводить быстрый аудит активных доступов в системе.  
  
Если вы будете использовать consul-template для автоматической перегенерации конфигов при изменении секретов, имейте в виду (и этого вы не найдете в документации), что consul-template опрашивает изменение секрета в двух случаях  
- Старт или рестарт самого consul-template.  
- Каждые (ttl секрета/2) секунд после старта consul-template.  
  
Чтобы не вводить свой рабочий токен постоянно, его можно положить в $HOME/.vault-token или в переменную окружения VAULT_TOKEN.  
