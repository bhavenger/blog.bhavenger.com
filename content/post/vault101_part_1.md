+++
date = "2016-07-20T22:19:01+03:00"
description = ""
draft = true
tags = ["vault", "hashicorp", "security"]
title = "vault101"
topics = []

+++

# Vault 101, или как решить множество проблем хранения секретов, часть первая.
## Disclaimer
Как и вы, я устал от многочисленных переводов зарубежных статей, которые, в свою очередь, часто являются пересказом официальной документации. Поэтому в первой части я перескажу официальную документацию самостоятельно ;-P, а во второй поделюсь своим реальным опытом использования и некоторыми неочевидными при первом приближении подробностями.

## Определения
Токен, он же ключ - комбинация символов, однозначно идентифицирующая клиента и разрешённый для него набор операций.    
Секрет - совокупность данных, необходимая для аутентификации и авторизации клиента на вашем сервисе(например логин и пароль от базы данных). Токен тоже является секретом по своей сути.  
Деплой - процесс доставки и развёртывания кода.  

## Какие проблемы решаем?
Разберём простую ситуацию - у вас есть сервис, состоящий из приложения на динамическом языке и реляционной базы данных. Приложение для своей работы использует данные, находящиеся в базе данных. Давайте посмотрим, какие секреты _скорее всего_ присутствуют в этой простейшей схеме?
1. Логин и пароль от базы данных для приложения(с ограниченным набором разрешённых операций).
2. Логин и пароль от базы данных для осуществления административных действий(создание и удаление баз данных, миграции, изменение конфигурации, whatever).
3. Ключ доступа на сервера для администратора.
4. Ключ доступа на сервер приложения для деплоя новой версии кода.
5. Ключ доступа на приватный репозиторий в GitHub(или любой другой хостинг, включая ваш собственный) для разработчика системы.
6. Ключ доступа на приватный репозиторий для системы деплоя.

Многовато получилось. А ведь это простейшая на первый взгляд схема.  
Что же делать, чтобы эти секреты не попали в руки злоумышленников? И при чём тут Vault? Давайте разбираться.

## Разбираемся.
Посмотрим на наш список секретов. Допустим мы храним ключи доступа администратора только на его ноутбуке в зашифрованном виде. О них можно практически не беспокоиться. Остаются два секрета доступа к базе данных(пользовательский и администраторский), ключ доступа на сервер приложения и ключ доступа к репозиторию для сервиса деплоя.
Всеми этими секретами так или иначе должен обладать сервис деплоя(он доставляет код с конфигом доступа к базе данных на сервер приложения; он накатывает миграции в процессе деплоя; он получает код из приватного репозитория).
Например вы используете Jenkins. Может быть отдать хранение секретов ему? Проблемы начинаются сразу после небольшого изыскания.
Любой, обладающий доступом к Jenkins может использовать ваши секреты в своей задаче - и таким образом получить к ним доступ.   Любой, кто получил доступ к Jenkins на уровне сервера - легко может [вытащить эти данные](http://thiébaud.fr/jenkins_credentials.html).
  
А что если хранить эти секреты в репозитории? Тут есть следующие проблемы:
Репозиторий хранится на сервере приложения и содержит секретов больше, чем необходимо самому приложению для работы.
Репозиторий хранится также и на сервере с Jenkins.
Вы не можете дать доступ к репозиторию без доступа ко всем секретам вашего сервиса.
  
Я настраиваю свои сервера с помощью системы управления конфигурациями. Почему бы не хранить эти секреты там?
Выглядит разумно - единая точка хранения секретов, Jenkins доступа не имеет. На конечных серверах можно раскладывать только тот набор секретов, который необходим и достаточен для работы.
Проблемы начинаются, когда доступ к вашему репозиторию получают другие люди. Ваш репозиторий становится единой точкой хранения всех секретов, к которым вы имеете доступ. Это очень небезопасно и очень неудобно. Например, после увольнения одного человека из тех, кто имел доступ к этому репозиторию, вы вынуждены поменять ВСЕ секреты, которым там были представлены. Также каждое появление этого репозитория где-либо в инфраструктуре добавляет вам точек отказа. Будь то Jenkins, разные chef\puppet-сервера для разных окружений или просто необходимость запускать по крону с одного сервера маленький скриптик, который хранится в этом репозитории - вы получаете риски в обмен на 'удобство' и возможность не думать про безопасность.
Опытные пользователи систем управления конфигурациями скажут: "Это уже решили в моей $scm-name. Ansible vault, Puppet gpg-hiera, Chef encrypted data bags и так далее". Всё бы хорошо, но есть проблемы (куда без них): ключ для расшифровки этих хранилищ всё ещё доступен на большом количестве серверов. Вы по-прежнему не знаете, кто получал доступ к секретам, и не знаете, к каким именно секретам был доступ. Ок, что же всё-таки делать? Как можно было догадаться из названия статьи - использовать Hashicorp Vault!  

## Что это за Vault такой?
Vault - это хранилище секретов. Секреты хранятся в простом key-value виде. Доступ к хранилищу осуществляется исключительно через REST-API.
Основные фичи Vault:
- Все данные хранятся в зашифрованном контейнере. Получение самого контейнера не раскрывает данные.
- Гибкие политики доступа. Вы можете создать столько токенов для доступа и управления секретами, сколько вам нужно. И дать им именно те разрешения, которые необходимы и достаточны для выполнения работ, но не более того.
- Возможность аудирования доступа к секретам. Каждый запрос к Vault может и должен быть записан в лог для последующего аудита.
- Поддерживается автоматическая генерация секретов для нескольких популярных баз данных (postgresql, mysql, mssql, cassandra), для rabbitmq, ssh и для aws.
- Поддержка шифрования-дешифрования данных без их сохранения. Это может быть удобно для передачи данных в зашифрованном виде по незащищённым каналам связи.
- Поддержка полного жизненного цикла секрета: создание/отзыв/завершение срока хранения/продление.
- Уберфича, значимость которой сложно переоценить, это возможность создания собственного CA (Certificate Authority) для управления самоподписанными сертификатами внутри своей инфраструктуры.
- Наличие готовых модулей и плагинов для всех популярных систем управления конфигурацией.  

Продолжение во второй части?