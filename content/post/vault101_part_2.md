+++
date = "2016-07-26T22:25:15+03:00"
description = ""
draft = true
tags = []
title = "vault101_part_2"
topics = []

+++



## Начало работы  
  
Итак, после установки и запуска Vault (более подробно - в официальной документации и в https://www.amon.cx/blog/managing-all-secrets-with-vault/) в HA-режиме (я использую Consul для этого) возникают вопросы:
- Сколько ключей вам будет нужно для того, чтобы распечатать хранилище? (Распечатывание - это исключительно ручной процесс, во время которого зашифрованный контейнер с секретами помещается в память и восстанавливается мастер-ключ для расшифровки. Более подробно - тут). Каждый решает этот вопрос по-своему. Дать возможность распечатать хранилище одному человеку - большой риск, потому что при компрометации этого ключа\ключей злоумышленники получат доступ к хранилищу (но пока не к секретам). Надо понимать, что если вы не сможете набрать необходимый минимум ключей для распечатывания хранилища - доступ к данным будет утерян. Для себя я решил, что достаточно 4 владельцев ключей и 2 ключей для расшифровки.
- Сколько root-токенов будет в вашей системе? Эти токены должны использоваться только для управления политиками, ролями, настройками системы и выдачи токенов для сервисов. Надо понимать, что, чем меньше root-ключей в системе, тем меньше вероятности компрометации одного из ключей. Но чем меньше таких ключей в системе, тем больше всё завязывается на определенных людей, которые болеют, ходят в отпуск, в общем - бывают недоступны. Для себя я решил, что достаточно 4 владельцев root-ключей, это те же люди, что обладают ключами для распечатки хранилища.  
- Как вы будете хранить секреты и как вы будете управлять доступами к ним? Можно разделять по окружениям или сервисам. Или любым другим удобным вам способом. Для себя я выбрал следующую схему - /secret/$service_name/$env. Для каждого $service_name есть владелец, обладающий полным доступом для /secret/$service_name/* и умеющий создавать ключи в рамках своих доступов (например, read-only для автоматизированных запросов). И есть /secret/infra/*, где обслуживаются обще-инфраструктурные ключи (например, api-token для jenkins или реквизиты для доступа к пакетному репозиторию). Для себя я решил, что владельцы секретов общей инфраструктуры - это обладатели рутовых ключей.  
- Какой структуры секретов вы будете придерживаться?  
```
{secret: {infra: {dns: {dns_key_secret: {value: $dns_key_secret }}}}}
```
или, например
```
{secret: {infra: {dns: {dns_key_secret: $dns_key_secret }}}}
```
Нужно решить этот вопрос до того, как ваш список секретов начнет быстро расти и вы начнете прикручивать различные средства автоматизации.  
  
Ок, вы ответили на эти вопросы, засетапили себе сервис и начали его использовать, что дальше? А дальше просто эксплуатация и счастливая безопасная жизнь :)  
## Неочевидные и/или полезные вещи
Для того, чтобы созданный вами НЕ-root токен мог создавать новые токены, он должен иметь политику
```
path "auth/token/create" {
  policy = "write"
}
```
НЕ-root токен может создавать токен только с теми политиками, которыми он обладает. Это означает, что вам недостаточно выдать вашему токену политику $service_name-prod-root,
```
path "secret/$service_name/prod/*" {  
  policy = "write"  
}
```
которая обладает полным доступом к secret/$service_name/prod/*, но также нужно озаботиться, например, политикой $service_name-prod-read,
```
path "secret/$service_name/prod/*" {  
  policy = "read"  
}
```
и тогда вы сможете создавать токены для read-only доступа с помощью команды
```
vault token-create -policy=$service_name-prod-read
```  
  
Политики применяются по степени детализации. Это означает, что если вы сделаете рут-политику вида
```
path "secret/$service_name/prod/*" {  
  policy = "write"  
}
```
и захотите дать доступ на чтение политике $service_name-prod-database-read
```
path "secret/$service_name/prod/database/*" {  
  policy = "read"  
}
```
то вам нужно будет назначить токену, управляющему этим сервисом обе этих политики. После того, как вы это сделаете - вы не сможете писать в secret/$service_name/prod/database/*. Чтобы этого не случилось - вам придется уравновесить каждую детализированную политику на чтение, например видоизменить политику $service_name-prod-root так
```
path "secret/$service_name/prod/*" {  
  policy = "write"  
}

path "secret/$service_name/prod/database/*" {  
  policy = "write"  
}
```
  
Если токен был родительским для других токенов, то по умолчанию при отзыве этого токена все токены и секреты, созданные отзываемым токеном, отзываются рекурсивно. Этого можно избежать,  указав флаг -mode. Более подробно
```
vault token-revoke -h
```
  
ВАЖНО. Не существует простого способа узнать, какие ключи существуют в системе. Если вы создали токен и забыли о нём, не записав никакой информации, то вам придется дожидаться, пока у него закончится срок жизни. Root-токены не имеют срока жизни, поэтому будут висеть в вашей системе бесконечно.  
  
Чтобы избавиться от этой ситуации, во время создания нового токена в целях тестирования и проверки вы можете указать прекрасный флаг -ttl="1h", который устанавливает время жизни. Это позволит спокойно работать и не бояться бесконтрольно увеличить количество токенов.
  
Каждый токен имеет параметр --accessor, зная который можно взаимодействовать с токеном, не зная его самого (например, отзывать, обновлять, добавлять политики), например

```
vault token-revoke --accessor b30ee2a3-ea4b-9da0-3e5c-4189d375cad9
```
Хорошей практикой является записывание этих ключей для последующей работы с ними. Это позволяет проводить быстрый аудит активных доступов в системе.  
  
Если вы будете использовать consul-template для автоматической перегенерации конфигов при изменении секретов, имейте в виду (и этого вы не найдете в документации), что consul-template опрашивает изменение секрета в двух случаях  
- Старт или рестарт самого consul-template.  
- Каждые (ttl секрета/2) секунд после старта consul-template.  
  
Чтобы не вводить свой рабочий токен постоянно, его можно положить в $HOME/.vault-token или в переменную окружения VAULT_TOKEN.  
